#!/usr/bin/env bash
# Generated by ChatGPT 5 Thinking
# TODO: X256 func
# TODO: fix: truecolor detection with tput 256
# TODO: better COLOR_COMPAT_MODE handling
# TODO: if tput doesn't support part of the colors, fallback to ANSI for those
# TODO: add 24-bit color detection via tput (ncurses 6.2+)
# TODO: document RGB() and RGB_BG() usage
# TODO: White: 37 or 97 or (BG) 47 or 107? or Truecolor or 256-palette?
# TODO: implement COLOR_BACKEND
# --- global toggles ----------------------------------------------------------
# COLOR_TRUECOLOR_MODE:
#   true    = force truecolor (24-bit) enabled
#   false   = force truecolor disabled
#   normal  = auto-detect (default)
: "${COLOR_TRUECOLOR_MODE:=normal}"

# COLOR_COMPAT_MODE:
#   auto    = no forced downgrade (default)
#   mono    = blank all colors and attributes
#   basic8  = restrict to 8-color palette
#   basic16 = restrict to 16-color palette (keep bright FG; blank bright BG)
: "${COLOR_COMPAT_MODE:=auto}"

# COLOR_BACKEND:
#   auto    = use tput if available, otherwise ANSI escape codes
#   tput    = use tput for colors (forced)
#   ansi    = use ANSI escape codes (forced)
: "${COLOR_BACKEND:=auto}"

# COLOR_DISABLE_LIST:
#   comma-separated names to blank (e.g. "GRAY,BG_BLUE,BOLD,BRIGHT_RED")
: "${COLOR_DISABLE_LIST:=}"

# --- raw ESC (portable) ------------------------------------------------------
ESC="$(printf '\033')"

# --- ANSI fallback constants (base + bright) --------------------------------
ANSI_FG_BLACK="${ESC}[0;30m"
ANSI_FG_RED="${ESC}[0;31m"
ANSI_FG_GREEN="${ESC}[0;32m"
ANSI_FG_YELLOW="${ESC}[0;33m"
ANSI_FG_BLUE="${ESC}[0;34m"
ANSI_FG_MAGENTA="${ESC}[0;35m"
ANSI_FG_CYAN="${ESC}[0;36m"
ANSI_FG_WHITE="${ESC}[1;37m"   # bright white by tradition
ANSI_FG_GRAY="${ESC}[0;90m"    # bright black / gray

# Bright foreground (ANSI 90–97)
ANSI_BRIGHT_BLACK="${ESC}[90m"
ANSI_BRIGHT_RED="${ESC}[91m"
ANSI_BRIGHT_GREEN="${ESC}[92m"
ANSI_BRIGHT_YELLOW="${ESC}[93m"
ANSI_BRIGHT_BLUE="${ESC}[94m"
ANSI_BRIGHT_MAGENTA="${ESC}[95m"
ANSI_BRIGHT_CYAN="${ESC}[96m"
ANSI_BRIGHT_WHITE="${ESC}[97m"

# Background (ANSI 40–47) + bright background (ANSI 100–107)
ANSI_BG_BLACK="${ESC}[40m"
ANSI_BG_RED="${ESC}[41m"
ANSI_BG_GREEN="${ESC}[42m"
ANSI_BG_YELLOW="${ESC}[43m"
ANSI_BG_BLUE="${ESC}[44m"
ANSI_BG_MAGENTA="${ESC}[45m"
ANSI_BG_CYAN="${ESC}[46m"
ANSI_BG_WHITE="${ESC}[47m"
ANSI_BG_RESET="${ESC}[49m"

ANSI_BG_BRIGHT_BLACK="${ESC}[100m"
ANSI_BG_BRIGHT_RED="${ESC}[101m"
ANSI_BG_BRIGHT_GREEN="${ESC}[102m"
ANSI_BG_BRIGHT_YELLOW="${ESC}[103m"
ANSI_BG_BRIGHT_BLUE="${ESC}[104m"
ANSI_BG_BRIGHT_MAGENTA="${ESC}[105m"
ANSI_BG_BRIGHT_CYAN="${ESC}[106m"
ANSI_BG_BRIGHT_WHITE="${ESC}[107m"

ANSI_BOLD="${ESC}[1m"
ANSI_DIM="${ESC}[2m"
ANSI_UNDERLINE="${ESC}[4m"
ANSI_RESET="${ESC}[0m"

# dual naming for reset
NC="$ANSI_RESET"
RESET="$ANSI_RESET"

# --- tput detection ----------------------------------------------------------
_use_tput=false
_tput_colors=0
if command -v tput >/dev/null 2>&1 && [ -n "$TERM" ]; then
    if tput sgr0 >/dev/null 2>&1; then
        _use_tput=true
        _tput_colors="$(tput colors 2>/dev/null || printf '0')"
    fi
fi

# --- base palette (tput or ANSI) --------------------------------------------
if $_use_tput; then
    # base foreground 0..7
    RED="$(tput setaf 1)";     GREEN="$(tput setaf 2)"
    YELLOW="$(tput setaf 3)";  BLUE="$(tput setaf 4)"
    MAGENTA="$(tput setaf 5)"; CYAN="$(tput setaf 6)"
    WHITE="$(tput setaf 7)"
    if GRAY="$(tput setaf 8 2>/dev/null)"; then :; else GRAY="$ANSI_FG_GRAY"; fi

    # base background 0..7
    BG_BLACK="$(tput setab 0)"; BG_RED="$(tput setab 1)"; BG_GREEN="$(tput setab 2)"
    BG_YELLOW="$(tput setab 3)"; BG_BLUE="$(tput setab 4)"; BG_MAGENTA="$(tput setab 5)"
    BG_CYAN="$(tput setab 6)";  BG_WHITE="$(tput setab 7)"
    BG_RESET="$(tput op 2>/dev/null || printf '%s' "$ANSI_BG_RESET")"

    # attributes
    BOLD="$(tput bold)"; UNDERLINE="$(tput smul)"; DIM="$(tput dim 2>/dev/null || printf '')"
    RESET="$(tput sgr0)"; NC="$RESET"

    # bright colors via indices 8..15 when available
    if [ "${_tput_colors:-0}" -ge 16 ] 2>/dev/null; then
        BRIGHT_BLACK="$(tput setaf 8)"
        BRIGHT_RED="$(tput setaf 9)"
        BRIGHT_GREEN="$(tput setaf 10)"
        BRIGHT_YELLOW="$(tput setaf 11)"
        BRIGHT_BLUE="$(tput setaf 12)"
        BRIGHT_MAGENTA="$(tput setaf 13)"
        BRIGHT_CYAN="$(tput setaf 14)"
        BRIGHT_WHITE="$(tput setaf 15)"

        BG_BRIGHT_BLACK="$(tput setab 8)"
        BG_BRIGHT_RED="$(tput setab 9)"
        BG_BRIGHT_GREEN="$(tput setab 10)"
        BG_BRIGHT_YELLOW="$(tput setab 11)"
        BG_BRIGHT_BLUE="$(tput setab 12)"
        BG_BRIGHT_MAGENTA="$(tput setab 13)"
        BG_BRIGHT_CYAN="$(tput setab 14)"
        BG_BRIGHT_WHITE="$(tput setab 15)"
    else
        # fallback to ANSI bright for FG; BG bright may be unsafe on ancient terms
        BRIGHT_BLACK="$ANSI_BRIGHT_BLACK"
        BRIGHT_RED="$ANSI_BRIGHT_RED"
        BRIGHT_GREEN="$ANSI_BRIGHT_GREEN"
        BRIGHT_YELLOW="$ANSI_BRIGHT_YELLOW"
        BRIGHT_BLUE="$ANSI_BRIGHT_BLUE"
        BRIGHT_MAGENTA="$ANSI_BRIGHT_MAGENTA"
        BRIGHT_CYAN="$ANSI_BRIGHT_CYAN"
        BRIGHT_WHITE="$ANSI_BRIGHT_WHITE"

        # default to ANSI bright BG; will be blanked in basic16 or basic8 if requested
        BG_BRIGHT_BLACK="$ANSI_BG_BRIGHT_BLACK"
        BG_BRIGHT_RED="$ANSI_BG_BRIGHT_RED"
        BG_BRIGHT_GREEN="$ANSI_BG_BRIGHT_GREEN"
        BG_BRIGHT_YELLOW="$ANSI_BG_BRIGHT_YELLOW"
        BG_BRIGHT_BLUE="$ANSI_BG_BRIGHT_BLUE"
        BG_BRIGHT_MAGENTA="$ANSI_BG_BRIGHT_MAGENTA"
        BG_BRIGHT_CYAN="$ANSI_BG_BRIGHT_CYAN"
        BG_BRIGHT_WHITE="$ANSI_BG_BRIGHT_WHITE"
    fi
else
    # ANSI fallback (base)
    RED="$ANSI_FG_RED";     GREEN="$ANSI_FG_GREEN";   YELLOW="$ANSI_FG_YELLOW"
    BLUE="$ANSI_FG_BLUE";   MAGENTA="$ANSI_FG_MAGENTA"; CYAN="$ANSI_FG_CYAN"
    WHITE="$ANSI_FG_WHITE"; GRAY="$ANSI_FG_GRAY"

    BG_BLACK="$ANSI_BG_BLACK"; BG_RED="$ANSI_BG_RED"; BG_GREEN="$ANSI_BG_GREEN"
    BG_YELLOW="$ANSI_BG_YELLOW"; BG_BLUE="$ANSI_BG_BLUE"; BG_MAGENTA="$ANSI_BG_MAGENTA"
    BG_CYAN="$ANSI_BG_CYAN";  BG_WHITE="$ANSI_BG_WHITE"; BG_RESET="$ANSI_BG_RESET"

    BOLD="$ANSI_BOLD"; UNDERLINE="$ANSI_UNDERLINE"; DIM="$ANSI_DIM"
    RESET="$ANSI_RESET"; NC="$ANSI_RESET"

    # ANSI bright (FG + BG)
    BRIGHT_BLACK="$ANSI_BRIGHT_BLACK"
    BRIGHT_RED="$ANSI_BRIGHT_RED"
    BRIGHT_GREEN="$ANSI_BRIGHT_GREEN"
    BRIGHT_YELLOW="$ANSI_BRIGHT_YELLOW"
    BRIGHT_BLUE="$ANSI_BRIGHT_BLUE"
    BRIGHT_MAGENTA="$ANSI_BRIGHT_MAGENTA"
    BRIGHT_CYAN="$ANSI_BRIGHT_CYAN"
    BRIGHT_WHITE="$ANSI_BRIGHT_WHITE"

    BG_BRIGHT_BLACK="$ANSI_BG_BRIGHT_BLACK"
    BG_BRIGHT_RED="$ANSI_BG_BRIGHT_RED"
    BG_BRIGHT_GREEN="$ANSI_BG_BRIGHT_GREEN"
    BG_BRIGHT_YELLOW="$ANSI_BG_BRIGHT_YELLOW"
    BG_BRIGHT_BLUE="$ANSI_BG_BRIGHT_BLUE"
    BG_BRIGHT_MAGENTA="$ANSI_BG_BRIGHT_MAGENTA"
    BG_BRIGHT_CYAN="$ANSI_BG_BRIGHT_CYAN"
    BG_BRIGHT_WHITE="$ANSI_BG_BRIGHT_WHITE"
fi

# --- truecolor helpers (controlled by COLOR_TRUECOLOR_MODE) ------------------
_use_truecolor=false
case "$COLOR_TRUECOLOR_MODE" in
    true)   _use_truecolor=true ;;
    false)  _use_truecolor=false ;;
    normal)
        if [ "${COLORTERM:-}" = "truecolor" ] || [ "${COLORTERM:-}" = "24bit" ]; then
            _use_truecolor=true
        elif $_use_tput && [ "${_tput_colors:-0}" -ge 256 ] 2>/dev/null; then
            _use_truecolor=true
        fi
    ;;
esac

if $_use_truecolor; then
    RGB()    { printf '%s[38;2;%s;%s;%sm' "$ESC" "$1" "$2" "$3"; }   # $(RGB r g b)
    RGB_BG() { printf '%s[48;2;%s;%s;%sm' "$ESC" "$1" "$2" "$3"; }   # $(RGB_BG r g b)
else
    RGB()    { :; }
    RGB_BG() { :; }
fi

# --- compatibility layer for ancient terminals -------------------------------
_setvar() { eval "$1=\$2"; }
_in_csv() { case ",$2," in *,"$1",*) return 0 ;; *) return 1 ;; esac; }
_blank_vars() { for _v in "$@"; do eval "[ \"\${$_v+set}\" ] && $_v=''"; done; }

case "$COLOR_COMPAT_MODE" in
    mono)
        _blank_vars RED GREEN YELLOW BLUE MAGENTA CYAN WHITE GRAY \
                    BRIGHT_BLACK BRIGHT_RED BRIGHT_GREEN BRIGHT_YELLOW BRIGHT_BLUE BRIGHT_MAGENTA BRIGHT_CYAN BRIGHT_WHITE \
                    BG_BLACK BG_RED BG_GREEN BG_YELLOW BG_BLUE BG_MAGENTA BG_CYAN BG_WHITE BG_RESET \
                    BG_BRIGHT_BLACK BG_BRIGHT_RED BG_BRIGHT_GREEN BG_BRIGHT_YELLOW BG_BRIGHT_BLUE BG_BRIGHT_MAGENTA BG_BRIGHT_CYAN BG_BRIGHT_WHITE \
                    BOLD UNDERLINE DIM
        RESET='' ; NC=''
        ;;
    basic8)
        # keep only 8 base colors; blank gray and all bright FG/BG
        _blank_vars GRAY \
                    BRIGHT_BLACK BRIGHT_RED BRIGHT_GREEN BRIGHT_YELLOW BRIGHT_BLUE BRIGHT_MAGENTA BRIGHT_CYAN BRIGHT_WHITE \
                    BG_BRIGHT_BLACK BG_BRIGHT_RED BG_BRIGHT_GREEN BG_BRIGHT_YELLOW BG_BRIGHT_BLUE BG_BRIGHT_MAGENTA BG_BRIGHT_CYAN BG_BRIGHT_WHITE
        ;;
    basic16)
        # keep 16 colors: allow bright FG; blank bright BG (often flaky on old terms)
        _blank_vars GRAY \
                    BG_BRIGHT_BLACK BG_BRIGHT_RED BG_BRIGHT_GREEN BG_BRIGHT_YELLOW BG_BRIGHT_BLUE BG_BRIGHT_MAGENTA BG_BRIGHT_CYAN BG_BRIGHT_WHITE
        ;;
    auto|*) : ;;
esac

# explicit per-name disables
for _name in RED GREEN YELLOW BLUE MAGENTA CYAN WHITE GRAY \
             BRIGHT_BLACK BRIGHT_RED BRIGHT_GREEN BRIGHT_YELLOW BRIGHT_BLUE BRIGHT_MAGENTA BRIGHT_CYAN BRIGHT_WHITE \
             BG_BLACK BG_RED BG_GREEN BG_YELLOW BG_BLUE BG_MAGENTA BG_CYAN BG_WHITE BG_RESET \
             BG_BRIGHT_BLACK BG_BRIGHT_RED BG_BRIGHT_GREEN BG_BRIGHT_YELLOW BG_BRIGHT_BLUE BG_BRIGHT_MAGENTA BG_BRIGHT_CYAN BG_BRIGHT_WHITE \
             BOLD UNDERLINE DIM RESET NC; do
    if _in_csv "$_name" "$COLOR_DISABLE_LIST"; then _setvar "$_name" ''; fi
done
[ -z "$RESET" ] && NC=''

# --- optional utility --------------------------------------------------------
color_echo() {
    _c="$1"; shift
    printf '%s%s%s\n' "${_c}" "$*" "${RESET}"
}
